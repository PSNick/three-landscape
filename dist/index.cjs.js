"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("@babel/runtime/helpers/extends"),r=require("@babel/runtime/helpers/objectWithoutPropertiesLoose"),n=require("react"),t=require("@react-three/fiber"),a=require("three"),o=require("three-stdlib");function i(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}function u(e){if(e&&e.__esModule)return e;var r=Object.create(null);return e&&Object.keys(e).forEach((function(n){if("default"!==n){var t=Object.getOwnPropertyDescriptor(e,n);Object.defineProperty(r,n,t.get?t:{enumerable:!0,get:function(){return e[n]}})}})),r.default=e,Object.freeze(r)}var l=i(e),s=i(r),c=u(n),f=u(a),m=["tiles","splats","displacement","normal","diffuse","layers"];function p(e){var r=e.materialParameters,n=e.layers,t=e.splats,a=e.normals,o=e.diffuses,i=e.noise,u=r.displacementMap.image,l=u.width,s=u.height,f=v({materialParameters:r,layers:n,splats:t,normals:a,diffuses:o,noise:i});return c.createElement("mesh",{material:f,rotation:[-Math.PI/2,0,0],position:[0,-1,0]},c.createElement("planeBufferGeometry",{args:[l,s,l,s]}))}function v(e){var r=e.materialParameters,n=e.layers,t=e.splats,a=e.normals,o=e.diffuses,i=e.noise,u=new f.MeshStandardMaterial(l.default({},r));return u.onBeforeCompile=function(e){e.extensions={derivatives:!0},e.uniforms=l.default({},e.uniforms,{uNoise:{value:i},uNormal:{value:a},uDiffuse:{value:o},uSplat:{value:t}}),e.fragmentShader=e.fragmentShader.replace("uniform float opacity;","\n        uniform float opacity;\n        uniform sampler2D uNoise;\n        uniform sampler2D uNormal["+a.length+"];\n        uniform sampler2D uDiffuse["+o.length+"];\n        uniform sampler2D uSplat["+t.length+"];\n\n        \nfloat sum( vec3 v ) { return v.x+v.y+v.z; }\n\nvec4 textureNoTile( sampler2D samp, vec2 uv )\n{\n  // sample variation pattern\n  float k = texture2D( uNoise, 0.005*uv ).x; // cheap (cache friendly) lookup\n\n  // compute index\n  float l = k*8.0;\n  float f = fract(l);\n\n  float ia = floor(l);\n  float ib = ia + 1.0;\n\n  // offsets for the different virtual patterns\n  float v = 0.4;\n  vec2 offa = sin(vec2(3.0,7.0)*ia); // can replace with any other hash\n  vec2 offb = sin(vec2(3.0,7.0)*ib); // can replace with any other hash\n\n  // compute derivatives for mip-mapping, requires shader extension derivatives:true\n  vec2 dx = dFdx(uv), dy = dFdy(uv);\n\n  // sample the two closest virtual patterns\n  vec3 cola = textureGrad( samp, uv + v*offa, dx, dy ).xyz;\n  vec3 colb = textureGrad( samp, uv + v*offb, dx, dy ).xyz;\n\n  // // interpolate between the two virtual patterns\n  vec3 col = mix( cola, colb, smoothstep(0.2,0.8,f-0.1*sum(cola-colb)) );\n  return vec4(col,1.0);\n}\n\nvec4 blend_rnm(vec4 n1, vec4 n2){\n  vec3 t = n1.xyz*vec3( 2,  2, 2) + vec3(-1, -1,  0);\n  vec3 u = n2.xyz*vec3(-2, -2, 2) + vec3( 1,  1, -1);\n  vec3 r = t*dot(t, u) /t.z -u;\n  return vec4((r), 1.0) * 0.5 + 0.5;\n}\n\n/**\n* Adjusts the saturation of a color.\n*\n* @name czm_saturation\n* @glslFunction\n*\n* @param {vec3} rgb The color.\n* @param {float} adjustment The amount to adjust the saturation of the color.\n*\n* @returns {float} The color with the saturation adjusted.\n*\n* @example\n* vec3 greyScale = czm_saturation(color, 0.0);\n* vec3 doubleSaturation = czm_saturation(color, 2.0);\n*/\nvec4 czm_saturation(vec4 rgba, float adjustment)\n{\n    // Algorithm from Chapter 16 of OpenGL Shading Language\n    vec3 rgb = rgba.rgb;\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    vec3 intensity = vec3(dot(rgb, W));\n    return vec4(mix(intensity, rgb, adjustment), rgba.a);\n}\n\n        ").replace("#include <map_fragment>","\n        #include <map_fragment>\n        vec4 color_override = "+function(e){return e.filter((function(e){return e.diffuse})).map((function(e,r){var n=e.diffuse,t=d(n,r),a=t[0],o=t[1],i=t[2],u=n.repeat,l="texture2D(uSplat["+o+"], vUv)."+i,s="textureNoTile(uDiffuse["+a+"], vUv * vec2("+u[0]+","+u[1]+"))";return n.saturation&&(s="czm_saturation("+s+", "+n.saturation+")"),s+" * "+l})).join(" + ")}(n)+";\n        diffuseColor = vec4(color_override.rgb, 1.0);\n        ").replace("#include <normal_fragment_maps>","\n        vec3 mapN = texture2D( normalMap, vUv ).xyz *1.25 -0.25;\n        vec4 _b = vec4(mapN.rgb, 1.0);\n        "+function(e){return e.filter((function(e){return e.normal})).map((function(e,r){var n=e.normal,t=d(n,r),a=t[0],o=t[1],i=t[2],u=n.repeat;return"_b = blend_rnm(_b, "+("mix("+"vec4(0.5, 0.5, 1, 1)"+", "+("textureNoTile(uNormal["+a+"], vUv * vec2("+u[0]+","+u[1]+"))")+", "+("texture2D(uSplat["+o+"], vUv)."+i)+"*"+(n.weight||"1.0")+")")+")"})).join("; \n")}(n)+";\n\n        mapN = _b.rgb;\n        mapN.xy *= normalScale;\n\n        #ifdef USE_TANGENT\n          normal = normalize( vTBN * mapN );\n        #else\n          normal = perturbNormal2Arb( -vViewPosition, normal, mapN, faceDirection );\n        #endif\n      ")},u}function d(e,r){return[e.tile||r,function(e){return Math.floor(e/4)}(e.splat||r),function(e){return["r","g","b","a"][e%4]}(e.splat||r)]}exports.Terrain=function(e){var r=e.tiles,n=e.splats,a=e.displacement,i=e.normal;e.diffuse;for(var u=e.layers,l=s.default(e,m),v=t.useLoader(f.TextureLoader,a),d=t.useLoader(f.TextureLoader,i),h=t.useLoader(f.TextureLoader,"/simplex-noise.png"),b=[],g=[],x=[],y=0;y<n.length;y++)x.push(t.useLoader(o.TGALoader,n[y]));for(var _=0;_<r.length;_++)r[_].normal&&b.push(t.useLoader(f.TextureLoader,r[_].normal)),r[_].diffuse&&g.push(t.useLoader(f.TextureLoader,r[_].diffuse));return[].concat(b,g,[h]).map((function(e){e.wrapS=f.RepeatWrapping,e.wrapT=f.RepeatWrapping})),l.displacementMap=l.displacementMap||v,l.normalMap=l.normalMap||d,c.createElement(p,{materialParameters:l,splats:x,normals:b,diffuses:g,layers:u,noise:h})},exports.TerrainMesh=p,exports.terrainMaterial=v;
