"use strict";module.exports="\nfloat sum( vec3 v ) { return v.x+v.y+v.z; }\n\nvec4 textureNoTile( sampler2D samp, vec2 uv )\n{\n  // sample variation pattern\n  float k = texture2D( uNoise, 0.005*uv ).x; // cheap (cache friendly) lookup\n\n  // compute index\n  float l = k*8.0;\n  float f = fract(l);\n\n  float ia = floor(l);\n  float ib = ia + 1.0;\n\n  // offsets for the different virtual patterns\n  float v = 0.4;\n  vec2 offa = sin(vec2(3.0,7.0)*ia); // can replace with any other hash\n  vec2 offb = sin(vec2(3.0,7.0)*ib); // can replace with any other hash\n\n  // compute derivatives for mip-mapping, requires shader extension derivatives:true\n  vec2 dx = dFdx(uv), dy = dFdy(uv);\n\n  // sample the two closest virtual patterns\n  vec3 cola = textureGrad( samp, uv + v*offa, dx, dy ).xyz;\n  vec3 colb = textureGrad( samp, uv + v*offb, dx, dy ).xyz;\n\n  // // interpolate between the two virtual patterns\n  vec3 col = mix( cola, colb, smoothstep(0.2,0.8,f-0.1*sum(cola-colb)) );\n  return vec4(col,1.0);\n}\n\nvec4 blend_rnm(vec4 n1, vec4 n2){\n  vec3 t = n1.xyz*vec3( 2,  2, 2) + vec3(-1, -1,  0);\n  vec3 u = n2.xyz*vec3(-2, -2, 2) + vec3( 1,  1, -1);\n  vec3 r = t*dot(t, u) /t.z -u;\n  return vec4((r), 1.0) * 0.5 + 0.5;\n}\n\n/**\n* Adjusts the saturation of a color.\n*\n* @name czm_saturation\n* @glslFunction\n*\n* @param {vec3} rgb The color.\n* @param {float} adjustment The amount to adjust the saturation of the color.\n*\n* @returns {float} The color with the saturation adjusted.\n*\n* @example\n* vec3 greyScale = czm_saturation(color, 0.0);\n* vec3 doubleSaturation = czm_saturation(color, 2.0);\n*/\nvec4 czm_saturation(vec4 rgba, float adjustment)\n{\n    // Algorithm from Chapter 16 of OpenGL Shading Language\n    vec3 rgb = rgba.rgb;\n    const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    vec3 intensity = vec3(dot(rgb, W));\n    return vec4(mix(intensity, rgb, adjustment), rgba.a);\n}\n";
